# -*- coding: utf-8 -*-
"""파이썬편_기초 문법_데이터 사이언스 스쿨.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mMVfAffdG9_qkZUfaQCnA7EenhoqMc3X

# 2.1 파이썬을 계산기로 사용하기
"""

# 정수부가 0인 실수는 0을 생략할 수 있다
.1    # .1 = 0.1

"""# 2.2 부동소수점 실수 자료형

### 부동소수점 실수
프로그래밍 언어는 IEEE 754라는 국제표준에 따라 실수를 부동소수점 방식으로 표현한다. 부동소수점 방식에서는 숫자를 정수로 된 유효숫자와 정수로 된 지수의 곱으로 표현한다.
"""

123e2    # 123.0 x 100 = 12300.0

123e-2    # 123e-2 x 0.01 = 1.23

"""### 부동소수점 오차
예를 들어 0.1은 십진수로는 간단히 표현되지만 이진수로 나타내면 다음과 같이 0011이 무한히 반복되는 실수가 된다.

그런데 컴퓨터에는 하나의 숫자를 나타내기 위한 메모리가 제한되어 있어 0.1의 가장 비슷한 숫자로 저장된다.

0.1 = 0.1000000000000000055511151231257827021181583404541015625
"""

# 파이썬 콘솔이나 주피터 노트북에서 0.1 입력 시 그냥 0.1로 나타남

0.1

# Commented out IPython magic to ensure Python compatibility.
# 파이썬 콘솔이나 주피터 노트북과 같은 REPL 인터페이스에서 값이 출력될 때는 편의상 일정 소수점 이하를 생략하고 보여줌
# 소수점 이하 55자리까지 보고 싶으면 %precision 매직(magic)명령어 사용

# %precision 55

# 이 상태에서 다시 0.1이라고 입력하면 55자리까지의 유효숫자를 보여준다.
0.1

# Commented out IPython magic to ensure Python compatibility.
# 원래대로
# %precision %r

0.1

# 실수 계산 시 오차를 가질 수 있음
0.1 + 0.2 == 0.3

0.1 + 0.2

# Commented out IPython magic to ensure Python compatibility.
# %precision 55

0.3

# Commented out IPython magic to ensure Python compatibility.
# %precision %r

# round 명령을 사용해 유효숫자를 지정한 반올림을 한 후 비교
round(0.1 + 0.2, 5) == round(0.3, 5)

round((0.1 + 0.2) - 0.3, 5) == 0.0

"""### NaN과 Inf
부동소수점 자료형을 NaN과 Inf 값을 표현할 수 있다
"""

float('NaN')

float('Inf')

float('-Inf')

"""# 2.3 파이썬으로 글자를 출력하기

### 문자열 치환
"""

"2020.10.23".replace('.', '-')

'word with space'.replace(' ', '')

"""### format 메서드를 사용한 문자열 형식화"""

"내 이름은 {}입니다.".format('홍길동')

"내 이름은 {{{}}}입니다.".format('홍길동')

"{2}의 {0} 점수는 {1}점입니다. {1}점! {1}점!".format('수학', 100, '철수')

# 숫자 대신 인수 이름을 지정할 수 있다
'{a}점수: {x}점, {b}점수: {y}점'.format(a = '영어', b = '수학', x = 100, y = 90)

# 순서 숫자나 인수 이름을 지정하지 않으면 순서대로 입력
"{}점수: {}점, {}점수: {}점".format("영어", 100, "수학", 90)

"""### enumerate 함수"""

for i, e in enumerate(['a', 'b', 'c']):
    print('i = %d, e = %s' % (i, e))

s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
a1 = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]
a2 = [95, 90, 90, 90, 95, 100, 90, 80, 95, 90]
for i, (a1i, a2i) in enumerate(zip(a1, a2)):    # zip() 함수는 여러 개의 순회 가능한(iterable) 객체를 인자로 받아 동일한 개수로 이루어진 자료형을 묶어서 튜플의 형태로 반환한다.
    s[i] = a1i + a2i
s

"""### zip 함수"""

# 두 개의 리스트를 합쳐서 각 리스트 원소의 쌍을 원소로 가지는 하나의 리스트를 만든다.
# 파이썬3에서는 명시적으로 list 명령을 사용해야 리스트가 된다
a12 = list(zip(a1, a2))
a12

s = []
a1 = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]
a2 = [95, 90, 90, 90, 95, 100, 90, 80, 95, 90]

for a1i, a2i in zip(a1, a2):    # 소괄호로 표시된 묶음은 tuple
    s.append(a1i + a2i)
s

a12

a21 = list(zip(*a12))    # 리스트 변환
a21

list(zip(*a21))

"""### 딕셔너리 자료형의 키 반복
### 딕셔너리 자료형의 값 반복
### 딕셔너리 자료형의 키와 값의 쌍 반복
"""

x = {"a": 10, "b": 20}

for k in x.keys():
    print(k)

for v in x.values():
    print(v)

for k, v in x.items():
    print(k, v)

"""### 게임 캐릭터와 객체"""

class Character(object):
    
    def __init__(self):
        self.life = 1000
    
    def attacked(self):
        self.life -= 10
        print('공격받음! 생명력 =', self.life)

a = Character()
b = Character()
c = Character()

a.life, b.life, c.life

a.attacked()

b.attacked()

a.attacked()
a.attacked()
a.attacked()
a.attacked()

a.life, b.life, c.life

"""### 클래스 상속"""

# 만약 전사(Warrior), 마법사(Wizard) 등 다양한 직업을 가진 캐릭터가 있고, 각 캐릭터는 서로 다른 초기 속성값을 가지고 태어난다면 어떻게 프로그래밍해야 할까?
# 각각의 캐릭터를 별도의 클래스로 만들어도 되겠지만, 클래스 상속을 사용하면 이미 만들어진 클래스 코드를 재사용하여 다른 클래스를 생성할 수 있다.
# 이 때 상속을 받는 클래스를 자식 클래스(child class), 상속의 대상이 되는 클래스를 부모 클래스(parent class)라고 한다.

"""
class 자식클래스이름(부모클래스 이름):
    
    def __init__(self, 속성값1, 속성값2):
        super(자식클래스이름, self).__init__()
        자식클래스의 초기화 코드
"""

class Warrior(Character):

    def __init__(self):
        super(Warrior, self).__init__()
        self.strength = 15
        self.intelligence = 5

class Wizard(Character):

    def __init__(self):
        super(Wizard,self).__init__()
        self.strength = 5
        self.intelligence = 15

a = Warrior()
b = Wizard()

a.life, b.life

a.strength, b.strength

a.intelligence, b.intelligence

a.attacked()

b.attacked()

"""### 메서드 오버라이딩(Method Overriding)"""

# 부모 클래스, 전사 클래스, 마법사 클래스에 공통으로 attack이라는 메서드가 있지만, 각각 하는 일이 다를 때는 다음처럼 같은 이름의 메서드를 클래스별로 구현한다.

class Charcter(object):

    def __init__(self):
        self.life = 1000
    
    def attacked(self):
        self.life -= 10
        print('공격받음! 생명력 =', self.life)

    def attack(self):
        print('공격!')

class Warrior(Character):

    def __init__(self):
        super(Warrior, self).__init__()
        self.strength = 15
        self.intelligence = 5

    def attack(self):
        print('육탄 공격!')

class Wizard(Character):

    def __init__(self):
        super(Wizard, self).__init__()
        self.strength = 5
        self.intelligence = 15

    def attack(self):
        print('마법 공격!')

a = Charcter()
b = Warrior()
c = Wizard()

a.attack()

b.attack()

c.attack()

"""### 불변형 자료형과 변형 자료형"""

# 정수, 실수, 문자열, 튜플은 불변형 자료형
# 리스트, 딕셔너리는 변형 자료형
# 불변형 자료형은 데이터 값을 바꿀 때 메모리에 저장된 데이터 전체를 모두 없애고 새로 만들지만 변형 자료형은 할당된 메모리를 그냥 놔두고 메모리에 씌여있는 값만 바꾼다.

x = 1

id(x)

x = 2

id(x)

x = [1]

id(x)    # 리스트의 메모리 주소

id(x[0]) # 첫 번째 원소의 메모리 주소

x[0] = 2

id(x)    # 리스트 메모리 주소 유지

id(x[0])

x = (1,)

id(x)

id(x[0])

# 튜플은 원소가 가리키는 내용만 바꿀 수 없다
# 바꾸려면 튜플 전체를 다시 만들어야 한다
x[0] = 2

x = (2,)

id(x)    # 튜플 메모리 주소 변경됨

id(x[0]) # 튜플 원소 메모리 주소 변경됨

